- wrapper = @private_networks.empty? ? :horizontal_form_disabled : :horizontal_form
= simple_form_for @instance, url: plugin('compute').instances_path, method: :post, remote: request.xhr?, html: {data: {modal: true}, class: 'form-horizontal' }, wrapper: wrapper do |f|

  %div{class: modal? ? 'modal-body' : ''}
    - if @instance.errors.present?
      .alert.alert-error
        = render_errors(@instance.errors)

    - if @keypairs.blank?
      %p.alert.alert-warning
        There are no key pairs defined for your account. Without key pairs you can't access the server via ssh.
        You can define one
        = link_to 'here', keypairs_url()

    - if @private_networks.empty?
      - if current_user.is_allowed?("networking:network_private_create")
        = link_to 'New Private Network', plugin('networking').send("new_networks_private_path"), data: {modal: true}, class: 'btn btn-primary'
      - else
        = 'Please read '
        = link_to 'about CC Networking.', "#{sap_url_for('documentation')}docs/customer/networking/networks/how-to-guides/learn-network-ccloud-networking/", target: '_blank'

    = f.input :name, 
      placeholder: 'set your Instance Name',
      icon_hint: 'The name must not end with dot and number'

    = f.input :availability_zone_id, {label: "Availability zone",
      input_html:         {},
      as:                 :select,
      collection:         @availability_zones,
      selected:           @instance.availability_zone_id,
      required:           true}

    = f.input :security_groups, { label: "Security groups",
      input_html:         {multiple: true},
      as:                 :grouped_select,
      required:           true,
      collection:         grouped_security_groups(@security_groups),
      group_method:       :last,
      label_method:       -> (sg) { sg.name }}

    = f.input :keypair_id, { label: "Key pair",
      input_html:         {},
      as:                 :select,
      collection:         @keypairs,
      required:           true}

    = f.input :flavor_id, { label: "Flavor",
      as:                 :grouped_select,
      required:           true,
      collection:         grouped_flavors(@flavors),
      group_method:       :last,
      include_blank:      "Choose flavor",
      label_method:       -> (flavor) { flavor_label_for_select(flavor) }}

    #custom_root_disk_wrapper{class: 'hidden'}
      = f.input :custom_root_disk, 
        as: :boolean,
        wrapper: :horizontal_radio_and_checkboxes_4x8
    
    #custom_root_disk_size_wrapper{class: params[:custom_root_disk] ? '' : 'hidden'}
      = f.input :custom_root_disk_size, 
        placeholder: 'set your Custom Root Disk Size (GB)',
        label: 'Custom Root Disk Size in GB'

    #baremetal_image_id_wrapper{class:'hidden'}
      = f.input :baremetal_image_id, label: 'Baremetal Image',
        selected:      @instance.image_id, 
        as:            :grouped_select,
        collection:    grouped_images(@images, 'baremetal', @bootable_volumes),
        group_method:  :last,
        include_blank: "Choose image",
        required:      true
        
    #vmware_image_id_wrapper{class:'hidden'}
      = f.input :vmware_image_id, label: 'VMware Image',
        selected:      @instance.image_id, 
        as:            :grouped_select,
        collection:    grouped_images(@images, 'vmware', @bootable_volumes),
        group_method:  :last,
        include_blank: "Choose image",
        required:      true,
        icon_hint: "Please note that you only use images with a maximum size of 12GB. Otherwise the instance creation might fail.<br><br>If you need to use bigger images please go to <i>“Volumes & Snapshots -> Create New”</i> and create a bootable volume of the correct size.<br>Then you can create a new server and choose the bootable volume from the list of images."

    #kvm_image_id_wrapper{class:'hidden'}
      = f.input :kvm_image_id, label: 'KVM Image',
        selected:      @instance.image_id, 
        as:            :grouped_select,
        collection:    grouped_images(@images, 'kvm', @bootable_volumes),
        group_method:  :last,
        include_blank: "Choose image",
        required:      true

    #kvm_volume_type{class:'hidden'}
      = f.input :kvm_volume_type, label: 'KVM Volume Type',
        as: :select,
        collection: render_available_volume_types(@available_volume_types, 'kvm'),
        include_blank: "Choose volume type",
        required: true

    :javascript
      function renderImages() {
        if ($('#server_flavor_id option:selected').text().match(/ironic/)) {
          // baremetal
          console.debug("baremetal flavor selected");
          $('#baremetal_image_id_wrapper').removeClass('hidden');
          $('#kvm_image_id_wrapper').addClass('hidden');
          $('#vmware_image_id_wrapper').addClass('hidden');

          $('#server_vmware_image_id').val("");
          $('#server_kvm_image_id').val("");
          $('#kvm_volume_type').val("");

          // hide custom root disk for baremetal flavors
          $('#custom_root_disk_wrapper').addClass('hidden');
          $('#custom_root_disk_size_wrapper').addClass('hidden');
          $('#server_custom_root_disk_size').val('');
          $('#server_custom_root_disk').prop("checked", false);
          $('button:contains("Create")').prop('disabled', false);
          $('#kvm_volume_type').addClass('hidden');
        }
        else if ($('#server_flavor_id option:selected').text().match(/kvm/)) {
            // kvm
            console.debug("kvm flavor selected");
            $('#baremetal_image_id_wrapper').addClass('hidden');
            $('#kvm_image_id_wrapper').removeClass('hidden');
            $('#vmware_image_id_wrapper').addClass('hidden');

            $('#server_baremetal_image_id').val("");
            $('#server_vmware_image_id').val("");
            $('#server_custom_root_disk_size').val("");
            $('#custom_root_disk_wrapper').removeClass('hidden');
            $('button:contains("Create")').prop('disabled', false);
          }
        else if ($('#server_flavor_id').val() == "") {
          // hide if nothing is selected
          console.debug("no flavor selected");
          $('#baremetal_image_id_wrapper').addClass('hidden');
          $('#kvm_image_id_wrapper').addClass('hidden');
          $('#vmware_image_id_wrapper').addClass('hidden');

          $('#server_baremetal_image_id').val("");
          $('#server_vmware_image_id').val("");
          $('#server_kvm_image_id').val("");
          $('#kvm_volume_type').val("");
          $('#server_custom_root_disk_size').val("");
          $('#custom_root_disk_wrapper').addClass('hidden');
          $('button:contains("Create")').prop('disabled', false);
          $('#kvm_volume_type').addClass('hidden');
        }
        else {
          // vmware
          console.debug("vmware flavor selected");
          $('#baremetal_image_id_wrapper').addClass('hidden');
          $('#kvm_image_id_wrapper').addClass('hidden');
          $('#vmware_image_id_wrapper').removeClass('hidden');

          $('#server_baremetal_image_id').val("");
          $('#server_kvm_image_id').val("");
          $('#kvm_volume_type').val("");
          $('#server_custom_root_disk_size').val("");
          $('#custom_root_disk_wrapper').removeClass('hidden');
          $('button:contains("Create")').prop('disabled', false);
          $('#kvm_volume_type').addClass('hidden');
        }
      }

      function handleDiskSizeChange() {
          var $input = $('#server_custom_root_disk_size');
          var value = $input.val().trim();
          var numericValue = parseInt(value);
          
          if (value === '') {
              $('button:contains("Create")').prop('disabled', true);
          } else if (isNaN(numericValue) || numericValue <= 10) {
              $('button:contains("Create")').prop('disabled', true);
          } else {
              console.debug('valid disk size entered:', numericValue + 'GB');
              $('button:contains("Create")').prop('disabled', false);
          }
      }

      function forceCustomRootDisk() {
        // handle custom root disk
        if ($('#server_flavor_id option:selected').text().match(/Disk: 0/)){
          // force custom root disk
          console.debug("force custom root disk");
          toggleRootDisk(true)
          // hide the checkbox
          $('#custom_root_disk_wrapper').addClass('hidden')
          // set default custom root disk size to 64GB
          $('#server_custom_root_disk_size').val('64')
          $('#server_custom_root_disk_size').trigger('change')
          // set kvm volume type to default
          $('#kvm_volume_type').removeClass('hidden');
          $('#server_kvm_volume_type').prop('selectedIndex', 1).trigger('change');
        } else {
          // reset values
          console.debug("reset values custom root disk");
          toggleRootDisk(false)
          $('#kvm_volume_type').addClass('hidden');
        }
      }

      function toggleRootDisk(show, currentDiskSize = '') {
        var server_custom_root_disk_size = currentDiskSize;
        if(show) {
          // hide bootable volumes if custom root disk is choosen
          $('#vmware_image_id_wrapper').val('')
          $('#vmware_image_id_wrapper').find('optgroup[label="--bootable volumes"]').addClass('hidden')
          $('#kvm_image_id_wrapper').val('')
          $('#kvm_image_id_wrapper').find('optgroup[label="--bootable volumes"]').addClass('hidden')
          $('#custom_root_disk_size_wrapper').removeClass('hidden')
          $('button:contains("Create")').prop('disabled', true);
          // restore value if available
          if (server_custom_root_disk_size != '' && server_custom_root_disk_size != '0') {
            $('#server_custom_root_disk_size').val(server_custom_root_disk_size)
          }
        } else {
          // show bootable volumes again
          $('#vmware_image_id_wrapper').find('optgroup[label="--bootable volumes"]').removeClass('hidden')
          $('#kvm_image_id_wrapper').find('optgroup[label="--bootable volumes"]').removeClass('hidden')
          $('#custom_root_disk_size_wrapper').addClass('hidden')
          $('button:contains("Create")').prop('disabled', false);
          $('#server_custom_root_disk').prop("checked", false);
          // store value and reset field
          server_custom_root_disk_size = $('#server_custom_root_disk_size').val()
          $('#server_custom_root_disk_size').val('')
        }
        return server_custom_root_disk_size;
      }

      function checkKvmVolumeType() {
        var flavorText = $('#server_flavor_id option:selected').text();
        var volumeTypeSelected = $('#server_kvm_volume_type').val() !== "";

        if (flavorText.match(/kvm/) && flavorText.match(/Disk: 0/) && !volumeTypeSelected) {
          console.debug("kvm flavor with 0 disk and no volume type selected");
          $('button:contains("Create")').prop('disabled', true);
        } else {
          $('button:contains("Create")').prop('disabled', false);
        }
      }

      $(document).ready(function(){
        // this is needed to set the correct visibility if we re-render in case of error
        // initial render of images based on the selected flavor
        renderImages()
        // check if custom root disk is needed
        forceCustomRootDisk()
        // initial check of disk size
        handleDiskSizeChange()
        // initial check of kvm volume type
        checkKvmVolumeType()

        // Root Disk Toggle
        var server_custom_root_disk_size = ''
        $('#server_custom_root_disk').change(function(t) {
          server_custom_root_disk_size = toggleRootDisk($('#server_custom_root_disk').is(':checked'), server_custom_root_disk_size)
        })

        // show images based on the selected flavor
        $('#server_flavor_id').change(function(){
          renderImages()
          forceCustomRootDisk()
        })
        // check for kvm volume type if visible
        $('#server_kvm_volume_type').change(function() {
          checkKvmVolumeType()
        });

        // check for custom root disk size if visible
        // Listen for input changes (real-time)
        $('#server_custom_root_disk_size').on('input', handleDiskSizeChange);
        // Also listen for blur (when user leaves the field)
        $('#server_custom_root_disk_size').on('blur', handleDiskSizeChange);

      });

    = f.input :network_ids, { label: "Private Network",
      wrapper_html:       { class: ('has-error' if @private_networks.empty?) },
      input_html:         {name: "#{@instance.model_name.param_key}[network_ids][][id]" },
      as:                 :select,
      collection:         @private_networks,
      selected:           (@instance.network_ids || []).collect{|n| n['id']},
      required:           true,
      include_blank:      "Choose network"}

    %p.u-clearfix
      = link_to "Toggle advanced network options","#", data: {action: 'toggle', target: '.advanced-options'}, class: "pull-right"

    .advanced-options.hidden
      .row
        .col-md-3
        .col-md-8
          %h5 Advanced Network Options
          %p
            These optional settings are for advanced usecases that require more control over the network configuration of the new instance. The only way we can offer these options is by creating a port first in the selected subnet or with the selected fixed IP and then adding the port to the instance at creation time. Please read the below warning carefully.
          .alert.alert-warning
            %strong Warning:
            These specifically created ports won't be deleted when the server is deleted, floating IPs you might have attached won't be released from the port automatically either. We recommend using these options only if it is necessary for your use case and then take care that you clean up the ports manually.

          = f.input :subnet_id, { label: "Subnet",
            as:                 :select,
            input_html:         {name: "#{@instance.model_name.param_key}[network_ids][][subnet_id]" },
            collection:         @subnets,
            label_method:       -> (subnet) { "#{subnet.name} (#{subnet.cidr})" },
            include_blank:      "Choose subnet",
            selected:           (@instance.network_ids || []).collect{|n| n['subnet_id']},
            icon_hint:          'You can specify a subnet from which the fixed IP is chosen. If empty any subnet is selected'}

          = f.input :port_id, {as: :hidden, input_html: {name: "#{@instance.model_name.param_key}[network_ids][][port]" }}
          = f.input :fixed_ip, { label: 'Server fixed IP',
            input_html: {name: "#{@instance.model_name.param_key}[network_ids][][fixed_ip]", value: (@instance.network_ids.try(:first) || {})['fixed_ip']},
            icon_hint: 'Choose a previously reserved IP or type a new one. Leave empty to let the DHCP select one for you.'}
        .col-md-1

    = f.input :user_data,
      label:              "User data",
      as:                 :text,
      required:           false,
      input_html:         {rows: "15", class: "u-text-monospace"}


  %div.buttons{class: modal? ? 'modal-footer' : ''}
    - if modal?
      %button.btn.btn-default{type:"button", data: {dismiss:"modal"}, aria: {label: "Cancel"}} Cancel
    - else
      = link_to "Cancel", instances_url(), class: 'btn btn-default'
    = button_tag "Create", { class: 'btn btn-primary pull-right', data: { disable_with: "Please wait..." } }

:javascript
  $(document).ready(function(){
    $('#server_fixed_ip').fixedIpSelector({
      subnetSelector: '#server_subnet_id',
      networkSelector: '#server_network_ids',
      portSelector: '#server_port_id',
      subnets: #{@subnets.to_json.html_safe},
      ports: #{@fixed_ip_ports.to_json.html_safe}
    })
  });
