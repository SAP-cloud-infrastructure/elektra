{"version":3,"sources":["../src/index.ts","../src/shadow-queries.ts","../src/trick-dom-testing-library.ts","../src/deep-query-selectors.ts","../src/log-shadow-dom.ts","../src/pretty-shadow-dom.ts","../src/debug.ts","../src/shadow-screen.ts","../src/shadow-within.ts"],"sourcesContent":["import { configure, getConfig } from \"@testing-library/dom\";\n\nimport * as shadowQueries from \"./shadow-queries\";\nimport { debug } from \"./debug\";\nimport { logShadowDOM } from \"./log-shadow-dom\";\nimport { prettyShadowDOM } from \"./pretty-shadow-dom\";\nimport { shadowScreen } from \"./shadow-screen\";\nimport { shadowWithin } from \"./shadow-within\";\n\nconfigure({\n  // https://github.com/testing-library/dom-testing-library/blob/39a64d4b862f706d09f0cd225ce9eda892f1e8d8/src/config.ts#L36-L51\n  getElementError(message, container) {\n    const prettifiedDOM = prettyShadowDOM(container);\n    const error = new Error(\n      [\n        message,\n        `Ignored nodes: comments, ${\n          getConfig().defaultIgnore\n        }\\n${prettifiedDOM}`,\n      ]\n        .filter(Boolean)\n        .join(\"\\n\\n\"),\n    );\n    error.name = \"ShadowDOMTestingLibraryElementError\";\n    return error;\n  },\n});\n\nexport * from \"./types\";\nexport * from \"./shadow-queries\";\n\nexport { createDOMElementFilter } from \"./pretty-shadow-dom\";\n\nexport {\n  deepQuerySelector,\n  deepQuerySelectorAll,\n  getAllElementsAndShadowRoots,\n} from \"./deep-query-selectors\";\n\nexport {\n  shadowScreen as screen,\n  shadowWithin as within,\n  shadowQueries,\n  debug,\n  logShadowDOM,\n  prettyShadowDOM,\n};\n","import {\n  buildQueries,\n  ByRoleMatcher,\n  queryAllByRole,\n  queryAllByLabelText,\n  Matcher,\n  queryAllByPlaceholderText,\n  queryAllByText,\n  queryAllByDisplayValue,\n  queryAllByAltText,\n  queryAllByTitle,\n  queryAllByTestId,\n  AllByRole,\n  AllByText,\n  AllByBoundAttribute,\n  GetByRole,\n  QueryByRole,\n  FindByRole,\n  FindAllByRole,\n  QueryByText,\n  GetByText,\n  FindAllByText,\n  FindByText,\n  QueryByBoundAttribute,\n  GetByBoundAttribute,\n  FindAllByBoundAttribute,\n  FindByBoundAttribute,\n} from \"@testing-library/dom\";\n\nimport { getAllElementsAndShadowRoots } from \"./deep-query-selectors\";\nimport { patchWrap } from \"./trick-dom-testing-library\";\nimport {\n  ScreenShadowMatcherParams,\n  ScreenShadowRoleMatcherParams,\n  ScreenShadowSelectorMatcherParams,\n  ShadowMatcherParams,\n  ShadowRoleMatcherParams,\n  ShadowSelectorMatcherParams,\n} from \"./types\";\n\nfunction toShadowQueries<T extends Function[]>(queries: T): T {\n  return queries.map((query): Function => {\n    return (...args: any[]): unknown => {\n      let [arg1, arg2, options, ...rest] = args;\n      if (options == null) options = {};\n      options.suggest = false;\n      return query(arg1, arg2, options, ...rest);\n    };\n  }) as T;\n}\n\n// Role\nfunction queryAllByShadowRole<T extends HTMLElement = HTMLElement>(\n  ...args: ShadowRoleMatcherParams\n): ReturnType<AllByRole<T>> {\n  let [container, role, options] = args;\n\n  if (options == null) {\n    options = {};\n  }\n\n  options.suggest = false;\n\n  return [\n    ...new Set(\n      patchWrap(() =>\n        getAllElementsAndShadowRoots(container, options)\n          .map((el) => queryAllByRole(el as HTMLElement, role, options))\n          .flat(Infinity),\n      ),\n    ),\n  ] as T[];\n}\n\nconst getMultipleRoleError = (_c: Element | null, role: ByRoleMatcher) =>\n  `Found multiple elements with the role of: ${role}`;\nconst getMissingRoleError = (_c: Element | null, role: ByRoleMatcher) =>\n  `Unable to find an element with the role of: ${role}`;\n\nconst [\n  _queryByShadowRole,\n  _getAllByShadowRole,\n  _getByShadowRole,\n  _findAllByShadowRole,\n  _findByShadowRole,\n] = toShadowQueries(\n  buildQueries<ScreenShadowRoleMatcherParams>(\n    queryAllByShadowRole,\n    getMultipleRoleError,\n    getMissingRoleError,\n  ),\n);\n\nconst queryByShadowRole = <T extends HTMLElement>(\n  ...args: Parameters<typeof _queryByShadowRole>\n) => _queryByShadowRole(...args) as ReturnType<QueryByRole<T>>;\nconst getAllByShadowRole = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getAllByShadowRole>\n) => _getAllByShadowRole(...args) as Array<ReturnType<GetByRole<T>>>;\nconst getByShadowRole = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getByShadowRole>\n) => _getByShadowRole(...args) as ReturnType<GetByRole<T>>;\nconst findAllByShadowRole = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findAllByShadowRole>\n) => _findAllByShadowRole(...args) as ReturnType<FindAllByRole<T>>;\nconst findByShadowRole = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findByShadowRole>\n) => _findByShadowRole(...args) as ReturnType<FindByRole<T>>;\n\n// Label Text\nfunction queryAllByShadowLabelText<T extends HTMLElement = HTMLElement>(\n  ...args: ShadowSelectorMatcherParams\n): ReturnType<AllByText<T>> {\n  let [container, id, options] = args;\n\n  if (options == null) {\n    options = {};\n  }\n\n  options.suggest = false;\n\n  return [\n    ...new Set(\n      patchWrap(() =>\n        getAllElementsAndShadowRoots(container, options)\n          .map((el) => queryAllByLabelText(el as HTMLElement, id, options))\n          .flat(Infinity),\n      ),\n    ),\n  ] as T[];\n}\n\nconst getMultipleLabelTextError = (_c: Element | null, id: Matcher) =>\n  `Found multiple elements with the label text of: ${id}`;\nconst getMissingLabelTextError = (_c: Element | null, id: Matcher) =>\n  `Unable to find an element with the label text of: ${id}`;\n\nconst [\n  _queryByShadowLabelText,\n  _getAllByShadowLabelText,\n  _getByShadowLabelText,\n  _findAllByShadowLabelText,\n  _findByShadowLabelText,\n] = toShadowQueries(\n  buildQueries<ScreenShadowSelectorMatcherParams>(\n    queryAllByShadowLabelText,\n    getMultipleLabelTextError,\n    getMissingLabelTextError,\n  ),\n);\n\nconst queryByShadowLabelText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _queryByShadowLabelText>\n) => _queryByShadowLabelText(...args) as ReturnType<QueryByText<T>>;\nconst getAllByShadowLabelText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getAllByShadowLabelText>\n) => _getAllByShadowLabelText(...args) as Array<ReturnType<GetByText<T>>>;\nconst getByShadowLabelText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getByShadowLabelText>\n) => _getByShadowLabelText(...args) as ReturnType<GetByText<T>>;\nconst findAllByShadowLabelText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findAllByShadowLabelText>\n) => _findAllByShadowLabelText(...args) as ReturnType<FindAllByText<T>>;\nconst findByShadowLabelText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findByShadowLabelText>\n) => _findByShadowLabelText(...args) as ReturnType<FindByText<T>>;\n\n// Placeholder Text\nfunction queryAllByShadowPlaceholderText<T extends HTMLElement = HTMLElement>(\n  ...args: ShadowMatcherParams\n): ReturnType<AllByText<T>> {\n  let [container, id, options] = args;\n\n  if (options == null) {\n    options = {};\n  }\n\n  options.suggest = false;\n\n  return [\n    ...new Set(\n      patchWrap(() =>\n        getAllElementsAndShadowRoots(container, options)\n          .map((el) =>\n            queryAllByPlaceholderText(el as HTMLElement, id, options),\n          )\n          .flat(Infinity),\n      ),\n    ),\n  ] as T[];\n}\n\nconst getMultiplePlaceholderTextError = (_c: Element | null, id: Matcher) =>\n  `Found multiple elements with the placeholder text of: ${id}`;\nconst getMissingPlaceholderTextError = (_c: Element | null, id: Matcher) =>\n  `Unable to find an element with the placeholder text of: ${id}`;\n\nconst [\n  _queryByShadowPlaceholderText,\n  _getAllByShadowPlaceholderText,\n  _getByShadowPlaceholderText,\n  _findAllByShadowPlaceholderText,\n  _findByShadowPlaceholderText,\n] = toShadowQueries(\n  buildQueries<ScreenShadowSelectorMatcherParams>(\n    queryAllByShadowPlaceholderText,\n    getMultiplePlaceholderTextError,\n    getMissingPlaceholderTextError,\n  ),\n);\n\nconst queryByShadowPlaceholderText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _queryByShadowPlaceholderText>\n) => _queryByShadowPlaceholderText(...args) as ReturnType<QueryByText<T>>;\nconst getAllByShadowPlaceholderText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getAllByShadowPlaceholderText>\n) => _getAllByShadowPlaceholderText(...args) as Array<ReturnType<GetByText<T>>>;\nconst getByShadowPlaceholderText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getByShadowPlaceholderText>\n) => _getByShadowPlaceholderText(...args) as ReturnType<GetByText<T>>;\nconst findAllByShadowPlaceholderText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findAllByShadowPlaceholderText>\n) => _findAllByShadowPlaceholderText(...args) as ReturnType<FindAllByText<T>>;\nconst findByShadowPlaceholderText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findByShadowPlaceholderText>\n) => _findByShadowPlaceholderText(...args) as ReturnType<FindByText<T>>;\n\n// Text\nfunction queryAllByShadowText<T extends HTMLElement = HTMLElement>(\n  ...args: ShadowSelectorMatcherParams\n): ReturnType<AllByText<T>> {\n  let [container, id, options] = args;\n\n  if (options == null) {\n    options = {};\n  }\n\n  options.suggest = false;\n\n  return [\n    ...new Set(\n      patchWrap(() =>\n        getAllElementsAndShadowRoots(container, options)\n          .map((el) => queryAllByText(el as HTMLElement, id, options))\n          .flat(Infinity),\n      ),\n    ),\n  ] as T[];\n}\n\nconst getMultipleTextError = (_c: Element | null, id: Matcher) =>\n  `Found multiple elements with the text of: ${id}`;\nconst getMissingTextError = (_c: Element | null, id: Matcher) =>\n  `Unable to find an element with the text of: ${id}`;\n\nconst [\n  _queryByShadowText,\n  _getAllByShadowText,\n  _getByShadowText,\n  _findAllByShadowText,\n  _findByShadowText,\n] = toShadowQueries(\n  buildQueries<ScreenShadowSelectorMatcherParams>(\n    queryAllByShadowText,\n    getMultipleTextError,\n    getMissingTextError,\n  ),\n);\n\nconst queryByShadowText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _queryByShadowText>\n) => _queryByShadowText(...args) as ReturnType<QueryByText<T>>;\nconst getAllByShadowText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getAllByShadowText>\n) => _getAllByShadowText(...args) as Array<ReturnType<GetByText<T>>>;\nconst getByShadowText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getByShadowText>\n) => _getByShadowText(...args) as ReturnType<GetByText<T>>;\nconst findAllByShadowText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findAllByShadowText>\n) => _findAllByShadowText(...args) as ReturnType<FindAllByText<T>>;\nconst findByShadowText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findByShadowText>\n) => _findByShadowText(...args) as ReturnType<FindByText<T>>;\n\n// Display Value\nfunction queryAllByShadowDisplayValue<T extends HTMLElement = HTMLElement>(\n  ...args: ShadowSelectorMatcherParams\n): ReturnType<AllByBoundAttribute<T>> {\n  let [container, id, options] = args;\n\n  if (options == null) {\n    options = {};\n  }\n\n  options.suggest = false;\n\n  return [\n    ...new Set(\n      patchWrap(() =>\n        getAllElementsAndShadowRoots(container, options)\n          .map((el) => queryAllByDisplayValue(el as HTMLElement, id, options))\n          .flat(Infinity),\n      ),\n    ),\n  ] as T[];\n}\n\nconst getMultipleDisplayValueError = (_c: Element | null, id: Matcher) =>\n  `Found multiple elements with the display value of: ${id}`;\nconst getMissingDisplayValueError = (_c: Element | null, id: Matcher) =>\n  `Unable to find an element with the display value of: ${id}`;\n\nconst [\n  _queryByShadowDisplayValue,\n  _getAllByShadowDisplayValue,\n  _getByShadowDisplayValue,\n  _findAllByShadowDisplayValue,\n  _findByShadowDisplayValue,\n] = toShadowQueries(\n  buildQueries<ScreenShadowSelectorMatcherParams>(\n    queryAllByShadowDisplayValue,\n    getMultipleDisplayValueError,\n    getMissingDisplayValueError,\n  ),\n);\n\nconst queryByShadowDisplayValue = <T extends HTMLElement>(\n  ...args: Parameters<typeof _queryByShadowDisplayValue>\n) =>\n  _queryByShadowDisplayValue(...args) as ReturnType<QueryByBoundAttribute<T>>;\nconst getAllByShadowDisplayValue = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getAllByShadowDisplayValue>\n) =>\n  _getAllByShadowDisplayValue(...args) as Array<\n    ReturnType<GetByBoundAttribute<T>>\n  >;\nconst getByShadowDisplayValue = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getByShadowDisplayValue>\n) => _getByShadowDisplayValue(...args) as ReturnType<GetByBoundAttribute<T>>;\nconst findAllByShadowDisplayValue = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findAllByShadowDisplayValue>\n) =>\n  _findAllByShadowDisplayValue(...args) as ReturnType<\n    FindAllByBoundAttribute<T>\n  >;\nconst findByShadowDisplayValue = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findByShadowDisplayValue>\n) => _findByShadowDisplayValue(...args) as ReturnType<FindByBoundAttribute<T>>;\n\n// Alt Text\nfunction queryAllByShadowAltText<T extends HTMLElement = HTMLElement>(\n  ...args: ShadowMatcherParams\n): ReturnType<AllByText<T>> {\n  let [container, id, options] = args;\n\n  if (options == null) {\n    options = {};\n  }\n\n  options.suggest = false;\n\n  return [\n    ...new Set(\n      patchWrap(() =>\n        getAllElementsAndShadowRoots(container, options)\n          .map((el) => queryAllByAltText(el as HTMLElement, id, options))\n          .flat(Infinity),\n      ),\n    ),\n  ] as T[];\n}\n\nconst getMultipleAltTextError = (_c: Element | null, id: Matcher) =>\n  `Found multiple elements with the alt text of: ${id}`;\nconst getMissingAltTextError = (_c: Element | null, id: Matcher) =>\n  `Unable to find an element with the alt text of: ${id}`;\n\nconst [\n  _queryByShadowAltText,\n  _getAllByShadowAltText,\n  _getByShadowAltText,\n  _findAllByShadowAltText,\n  _findByShadowAltText,\n] = toShadowQueries(\n  buildQueries<ScreenShadowMatcherParams>(\n    queryAllByShadowAltText,\n    getMultipleAltTextError,\n    getMissingAltTextError,\n  ),\n);\n\nconst queryByShadowAltText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _queryByShadowAltText>\n) => _queryByShadowAltText(...args) as ReturnType<QueryByText<T>>;\nconst getAllByShadowAltText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getAllByShadowAltText>\n) => _getAllByShadowAltText(...args) as Array<ReturnType<GetByText<T>>>;\nconst getByShadowAltText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getByShadowAltText>\n) => _getByShadowAltText(...args) as ReturnType<GetByText<T>>;\nconst findAllByShadowAltText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findAllByShadowAltText>\n) => _findAllByShadowAltText(...args) as ReturnType<FindAllByText<T>>;\nconst findByShadowAltText = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findByShadowAltText>\n) => _findByShadowAltText(...args) as ReturnType<FindByText<T>>;\n\n// Title\nfunction queryAllByShadowTitle<T extends HTMLElement = HTMLElement>(\n  ...args: ShadowMatcherParams\n): ReturnType<AllByBoundAttribute<T>> {\n  let [container, id, options] = args;\n\n  if (options == null) {\n    options = {};\n  }\n\n  options.suggest = false;\n\n  return [\n    ...new Set(\n      patchWrap(() =>\n        getAllElementsAndShadowRoots(container, options)\n          .map((el) => queryAllByTitle(el as HTMLElement, id, options))\n          .flat(Infinity),\n      ),\n    ),\n  ] as T[];\n}\n\nconst getMultipleTitleError = (_c: Element | null, id: Matcher) =>\n  `Found multiple elements with the title of: ${id}`;\nconst getMissingTitleError = (_c: Element | null, id: Matcher) =>\n  `Unable to find an element with the title of: ${id}`;\n\nconst [\n  _queryByShadowTitle,\n  _getAllByShadowTitle,\n  _getByShadowTitle,\n  _findAllByShadowTitle,\n  _findByShadowTitle,\n] = toShadowQueries(\n  buildQueries<ScreenShadowMatcherParams>(\n    queryAllByShadowTitle,\n    getMultipleTitleError,\n    getMissingTitleError,\n  ),\n);\n\nconst queryByShadowTitle = <T extends HTMLElement>(\n  ...args: Parameters<typeof _queryByShadowTitle>\n) => _queryByShadowTitle(...args) as ReturnType<QueryByBoundAttribute<T>>;\nconst getAllByShadowTitle = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getAllByShadowTitle>\n) => _getAllByShadowTitle(...args) as Array<ReturnType<GetByBoundAttribute<T>>>;\nconst getByShadowTitle = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getByShadowTitle>\n) => _getByShadowTitle(...args) as ReturnType<GetByBoundAttribute<T>>;\nconst findAllByShadowTitle = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findAllByShadowTitle>\n) => _findAllByShadowTitle(...args) as ReturnType<FindAllByBoundAttribute<T>>;\nconst findByShadowTitle = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findByShadowTitle>\n) => _findByShadowTitle(...args) as ReturnType<FindByBoundAttribute<T>>;\n\n// Test Id\nfunction queryAllByShadowTestId<T extends HTMLElement = HTMLElement>(\n  ...args: ShadowMatcherParams\n): ReturnType<AllByBoundAttribute<T>> {\n  let [container, id, options] = args;\n\n  if (options == null) {\n    options = {};\n  }\n\n  options.suggest = false;\n\n  return [\n    ...new Set(\n      patchWrap(() =>\n        getAllElementsAndShadowRoots(container, options)\n          .map((el) => queryAllByTestId(el as HTMLElement, id, options))\n          .flat(Infinity),\n      ),\n    ),\n  ] as T[];\n}\n\nconst getMultipleTestIdError = (_c: Element | null, id: Matcher) =>\n  `Found multiple elements with the test id of: ${id}`;\nconst getMissingTestIdError = (_c: Element | null, id: Matcher) =>\n  `Unable to find an element with the test id of: ${id}`;\n\nconst [\n  _queryByShadowTestId,\n  _getAllByShadowTestId,\n  _getByShadowTestId,\n  _findAllByShadowTestId,\n  _findByShadowTestId,\n] = toShadowQueries(\n  buildQueries<ScreenShadowMatcherParams>(\n    queryAllByShadowTestId,\n    getMultipleTestIdError,\n    getMissingTestIdError,\n  ),\n);\n\nconst queryByShadowTestId = <T extends HTMLElement>(\n  ...args: Parameters<typeof _queryByShadowTestId>\n) => _queryByShadowTestId(...args) as ReturnType<QueryByBoundAttribute<T>>;\nconst getAllByShadowTestId = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getAllByShadowTestId>\n) =>\n  _getAllByShadowTestId(...args) as Array<ReturnType<GetByBoundAttribute<T>>>;\nconst getByShadowTestId = <T extends HTMLElement>(\n  ...args: Parameters<typeof _getByShadowTestId>\n) => _getByShadowTestId(...args) as ReturnType<GetByBoundAttribute<T>>;\nconst findAllByShadowTestId = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findAllByShadowTestId>\n) => _findAllByShadowTestId(...args) as ReturnType<FindAllByBoundAttribute<T>>;\nconst findByShadowTestId = <T extends HTMLElement>(\n  ...args: Parameters<typeof _findByShadowTestId>\n) => _findByShadowTestId(...args) as ReturnType<FindByBoundAttribute<T>>;\n\nexport {\n  // Role\n  queryAllByShadowRole,\n  queryByShadowRole,\n  getAllByShadowRole,\n  getByShadowRole,\n  findAllByShadowRole,\n  findByShadowRole,\n\n  // Label Text\n  queryAllByShadowLabelText,\n  queryByShadowLabelText,\n  getAllByShadowLabelText,\n  getByShadowLabelText,\n  findAllByShadowLabelText,\n  findByShadowLabelText,\n\n  // Placeholder Text\n  queryAllByShadowPlaceholderText,\n  queryByShadowPlaceholderText,\n  getAllByShadowPlaceholderText,\n  getByShadowPlaceholderText,\n  findAllByShadowPlaceholderText,\n  findByShadowPlaceholderText,\n\n  // Text\n  queryAllByShadowText,\n  queryByShadowText,\n  getAllByShadowText,\n  getByShadowText,\n  findAllByShadowText,\n  findByShadowText,\n\n  // Display Value\n  queryAllByShadowDisplayValue,\n  queryByShadowDisplayValue,\n  getAllByShadowDisplayValue,\n  getByShadowDisplayValue,\n  findAllByShadowDisplayValue,\n  findByShadowDisplayValue,\n\n  // Alt Text\n  queryAllByShadowAltText,\n  queryByShadowAltText,\n  getAllByShadowAltText,\n  getByShadowAltText,\n  findAllByShadowAltText,\n  findByShadowAltText,\n\n  // Title\n  queryAllByShadowTitle,\n  queryByShadowTitle,\n  getAllByShadowTitle,\n  getByShadowTitle,\n  findAllByShadowTitle,\n  findByShadowTitle,\n\n  // Test Id\n  queryAllByShadowTestId,\n  queryByShadowTestId,\n  getAllByShadowTestId,\n  getByShadowTestId,\n  findAllByShadowTestId,\n  findByShadowTestId,\n};\n","declare global {\n  interface ShadowRoot {\n    matches?: typeof HTMLElement.prototype.matches;\n    outerHTML?: typeof HTMLElement.prototype.outerHTML;\n  }\n}\n\n// Okay. For some reason shadow root patches cant be part of patchDOM. Haven't figured out why.\n// Only reason I can come up with is the patchWrap() may be conflicting with internals of dom-testing-library?\n// I do know calling `.getByText(el.shadowRoot)` will fail without this patch.\n// outerHTML fails with some issue around \"this\".\n// IDK...but this is weird, no its not the most responsible patch, but it works.\n// Just dont go calling .matches() or .outerHTML() on shadowRoots in your code...\n// This previously existed in other version of SDTL so not a huge deal.\npatchShadowRoot();\n\n// Amazingly fun hack to trick DOM testing libraries internal type checking logic.\n// https://github.com/testing-library/dom-testing-library/blob/73a5694529dbfff289f3d7a01470c45ef5c77715/src/queries/text.ts#L34-L36\n// https://github.com/testing-library/dom-testing-library/blob/73a5694529dbfff289f3d7a01470c45ef5c77715/src/pretty-dom.js#L50-L54\nexport function patchDOM() {\n  patchSlotElement();\n}\n\nfunction removeDOMPatch() {\n  HTMLSlotElement.prototype.querySelectorAll =\n    HTMLElement.prototype.querySelectorAll;\n}\n\nexport function patchWrap<T extends (...args: any) => any>(\n  callback: T,\n): ReturnType<T> {\n  patchDOM();\n\n  try {\n    const val = callback();\n\n    // We only wrap RTL functions, so I dont think anything returns a promise, but just in-case,\n    // lets make sure we clean up.\n    if (\n      typeof val === \"object\" &&\n      \"finally\" in val &&\n      typeof val.finally === \"function\"\n    ) {\n      val.finally(() => removeDOMPatch());\n    }\n\n    return val;\n  } finally {\n    removeDOMPatch();\n  }\n}\n\nfunction patchShadowRoot() {\n  if (typeof ShadowRoot == \"undefined\")\n    throw \"Your environment does not support shadow roots.\";\n\n  if (ShadowRoot.prototype.matches == null) {\n    Object.defineProperties(ShadowRoot.prototype, {\n      matches: {\n        get() {\n          return function (this: ShadowRoot, string: string): boolean {\n            const str = string.trim();\n            if (str === \"*\") return true;\n\n            return Boolean(this.querySelector(string));\n          };\n        },\n      },\n    });\n  }\n\n  if (ShadowRoot.prototype.outerHTML == null) {\n    Object.defineProperties(ShadowRoot.prototype, {\n      outerHTML: {\n        get() {\n          return this.innerHTML;\n        },\n      },\n    });\n  }\n}\n\nfunction patchSlotElement() {\n  HTMLSlotElement.prototype.querySelectorAll = function (str: string) {\n    const qsa = HTMLElement.prototype.querySelectorAll;\n    let els: Element[] = [];\n\n    this.assignedElements({ flatten: true }).forEach((_el) => {\n      const el = _el as Element;\n\n      // Clone it and make a scratch buffer because we need to check that _el\n      // meets the criteria of the querySelector before we push it to \"els\"\n      const scratch = document.createElement(\"div\");\n      scratch.appendChild(el.cloneNode(false));\n\n      if (scratch.querySelector(str)) {\n        els.push(el);\n      }\n\n      els = els.concat(Array.from(el.querySelectorAll(str)));\n    });\n\n    // So because slots have fallback content, we want to only first query for slotted content.\n    // If theres no slotted content, we fallback to using the default content.\n    if (els.length == 0) {\n      els = Array.from(qsa.call(this, str));\n    }\n\n    return [...new Set(els)] as unknown as ReturnType<\n      typeof HTMLSlotElement.prototype.querySelectorAll\n    >;\n  };\n}\n","import { patchWrap } from \"./trick-dom-testing-library\";\nimport { Container, ShadowOptions } from \"./types\";\n\nexport function deepQuerySelector<T extends HTMLElement>(\n  container: Container,\n  selector: string,\n  options: ShadowOptions = { shallow: false },\n): T | null {\n  const els = deepQuerySelectorAll(container, selector, options);\n\n  if (Array.isArray(els) && els.length > 0) {\n    return els[0] as T | null;\n  }\n\n  return null;\n}\n\n/**\n * `deepQuerySelector` behaves like a normal querySelector except it will recurse into the container ShadowRoot\n * and shadowRoot of children. It will not return shadow roots.\n *\n * @example\n *   // <my-element>\n *   //   #shadowRoot <slot name=\"blah\"></slot>\n *   //   <div></div>\n *   // </my-element>\n *   deepQuerySelectorAll(myElement, \"*\") // => [slot, div]\n *   deepQuerySelectorAll(myElement, \"slot[name='blah']\") // => [slot]\n */\nexport function deepQuerySelectorAll<T extends HTMLElement>(\n  container: Container,\n  selector: string,\n  options: ShadowOptions = { shallow: false },\n): T[] {\n  return patchWrap(() => {\n    const elements = getAllElementsAndShadowRoots(container, options);\n\n    const queriedElements = elements\n      .map((el) => Array.from(el.querySelectorAll<T>(selector)))\n      .flat(Infinity) as T[];\n    return [...new Set(queriedElements)];\n  });\n}\n\n// This could probably get really slow and memory intensive in large DOMs,\n// maybe an infinite generator in the future?\nexport function getAllElementsAndShadowRoots(\n  container: Container,\n  options: ShadowOptions = { shallow: false },\n) {\n  const selector = \"*\";\n  return recurse(container, selector, options);\n}\n\nfunction recurse(\n  container: Container,\n  selector: string,\n  options: ShadowOptions = { shallow: false },\n  elementsToProcess: (Element | ShadowRoot | Document)[] = [],\n  elements: (Element | ShadowRoot | Document)[] = [],\n) {\n  // if \"document\" is passed in, it will also pick up \"<html>\" causing the query to run twice.\n  if (container instanceof Document) {\n    container = document.documentElement;\n  }\n\n  // I haven't figured this one out, but for some reason when using the buildQueries\n  // from DOM-testing-library, not reassigning here causes an infinite loop.\n  // I've even tried calling \"elementsToProcess.includes / .find\" with no luck.\n  elementsToProcess = [container];\n  elements.push(container); // Make sure we're checking the container element!\n\n  // Accounts for if the container houses a textNode\n  if (\n    container instanceof HTMLElement &&\n    container.shadowRoot != null &&\n    container.shadowRoot.mode !== \"closed\"\n  ) {\n    elements.push(container.shadowRoot);\n    elementsToProcess.push(container.shadowRoot);\n  }\n\n  elementsToProcess.forEach((containerElement) => {\n    containerElement\n      .querySelectorAll(selector)\n      .forEach((el: Element | HTMLElement) => {\n        if (el.shadowRoot == null || el.shadowRoot.mode === \"closed\") {\n          elements.push(el);\n          return;\n        }\n\n        // This is here because queryByRole() requires the parent element which in some cases is the shadow root.\n        elements.push(el.shadowRoot);\n\n        if (options.shallow === true) {\n          el.shadowRoot.querySelectorAll(selector).forEach((el) => {\n            elements.push(el);\n          });\n          return;\n        }\n\n        el.shadowRoot.querySelectorAll(selector).forEach((el) => {\n          elements.push(el);\n          elementsToProcess.push(el);\n        });\n        recurse(el.shadowRoot, selector, options, elementsToProcess, elements);\n      });\n  });\n\n  // We can sometimes hit duplicate nodes this way, lets stop that.\n  return [...new Set(elements)];\n}\n","import { logDOM } from \"@testing-library/dom\";\nimport {\n  createDOMElementFilter,\n  filterCommentsAndDefaultIgnoreTagsTags,\n} from \"./pretty-shadow-dom\";\nimport type { NewPlugin } from \"pretty-format\";\nimport { patchWrap } from \"./trick-dom-testing-library\";\n\nexport function logShadowDOM(\n  ...args: Parameters<typeof logDOM>\n): ReturnType<typeof logDOM> {\n  let [dom, maxLength, options] = args;\n\n  const plugin: NewPlugin = createDOMElementFilter(\n    options?.filterNode || filterCommentsAndDefaultIgnoreTagsTags,\n  );\n\n  if (options == null) options = {};\n  if (options.plugins == null) options.plugins = [];\n  options.plugins.push(plugin);\n\n  patchWrap(() => logDOM(dom, maxLength, options));\n}\n","import { prettyDOM, getConfig } from \"@testing-library/dom\";\nimport type { Config, NewPlugin, Printer, Refs } from \"pretty-format\";\nimport { patchWrap } from \"./trick-dom-testing-library\";\n\n// This regexp combo took way too long to figure out...\nconst findWhiteSpace = /([^\\S(\\r\\n|\\r|\\n)]*[\\f\\n\\r\\t\\v]+)/.source;\n\nfunction removeDuplicateNewLines(str: string) {\n  let final = str.replace(\n    new RegExp(`${findWhiteSpace}.*${findWhiteSpace}{2,}`, \"g\"),\n    \"\",\n  );\n  return final;\n}\n\nexport function prettyShadowDOM(\n  ...args: Parameters<typeof prettyDOM>\n): ReturnType<typeof prettyDOM> {\n  let [dom, maxLength, options] = args;\n\n  const plugin: NewPlugin = createDOMElementFilter(\n    options?.filterNode || filterCommentsAndDefaultIgnoreTagsTags,\n  );\n\n  if (options == null) options = {};\n  if (options.plugins == null) options.plugins = [];\n\n  options.plugins.push(plugin);\n\n  return patchWrap(() =>\n    prettyDOM(dom, maxLength, {\n      ...options,\n      plugins: [plugin],\n    }),\n  );\n}\n\nfunction escapeHTML(str: string): string {\n  return str.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\n\nexport function filterCommentsAndDefaultIgnoreTagsTags(value: Node) {\n  return (\n    value.nodeType !== COMMENT_NODE &&\n    (value.nodeType !== ELEMENT_NODE ||\n      // @ts-expect-error\n      !value.matches(getConfig().defaultIgnore))\n  );\n}\n\n// Return empty string if keys is empty.\nconst printProps = (\n  keys: Array<string>,\n  props: Record<string, unknown>,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n): string => {\n  const indentationNext = indentation + config.indent;\n  const colors = config.colors;\n\n  return keys\n    .map((key) => {\n      const value = props[key];\n      let printed = printer(value, config, indentationNext, depth, refs);\n\n      if (typeof value !== \"string\") {\n        if (printed.indexOf(\"\\n\") !== -1) {\n          printed =\n            config.spacingOuter +\n            indentationNext +\n            printed +\n            config.spacingOuter +\n            indentation;\n        }\n        printed = \"{\" + printed + \"}\";\n      }\n\n      return (\n        config.spacingInner +\n        indentation +\n        colors.prop.open +\n        key +\n        colors.prop.close +\n        \"=\" +\n        colors.value.open +\n        printed +\n        colors.value.close\n      );\n    })\n    .join(\"\");\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#node_type_constants\nconst NodeTypeTextNode = 3;\n\n// Return empty string if children is empty.\nconst printChildren = (\n  children: Array<unknown>,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n): string =>\n  removeDuplicateNewLines(\n    children\n      .map((child) => {\n        const printedChild =\n          typeof child === \"string\"\n            ? printText(child, config)\n            : printer(child, config, indentation, depth, refs);\n\n        if (\n          printedChild === \"\" &&\n          typeof child === \"object\" &&\n          child != null &&\n          (child as Node).nodeType !== NodeTypeTextNode\n        ) {\n          // A plugin serialized this Node to '' meaning we should ignore it.\n          return \"\";\n        }\n        return config.spacingOuter + indentation + printedChild;\n      })\n      .join(\"\"),\n  );\n\nconst printText = (text: string, config: Config): string => {\n  const contentColor = config.colors.content;\n  return contentColor.open + escapeHTML(text) + contentColor.close;\n};\n\nconst printComment = (comment: string, config: Config): string => {\n  const commentColor = config.colors.comment;\n  return (\n    commentColor.open +\n    \"<!--\" +\n    escapeHTML(comment) +\n    \"-->\" +\n    commentColor.close\n  );\n};\n\n// Separate the functions to format props, children, and element,\n// so a plugin could override a particular function, if needed.\n// Too bad, so sad: the traditional (but unnecessary) space\n// in a self-closing tagColor requires a second test of printedProps.\nconst printElement = (\n  type: string,\n  printedProps: string,\n  printedChildren: string,\n  config: Config,\n  indentation: string,\n): string => {\n  const tagColor = config.colors.tag;\n\n  return (\n    tagColor.open +\n    \"<\" +\n    type +\n    (printedProps &&\n      tagColor.close +\n        printedProps +\n        config.spacingOuter +\n        indentation +\n        tagColor.open) +\n    (printedChildren\n      ? \">\" +\n        tagColor.close +\n        printedChildren +\n        config.spacingOuter +\n        indentation +\n        tagColor.open +\n        \"</\" +\n        type\n      : (printedProps && !config.min ? \"\" : \" \") + \"/\") +\n    \">\" +\n    tagColor.close\n  );\n};\n\nconst printElementAsLeaf = (type: string, config: Config): string => {\n  const tagColor = config.colors.tag;\n  return (\n    tagColor.open +\n    \"<\" +\n    type +\n    tagColor.close +\n    \" …\" +\n    tagColor.open +\n    \" />\" +\n    tagColor.close\n  );\n};\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst FRAGMENT_NODE = 11;\n\nconst ELEMENT_REGEXP = /^((HTML|SVG)\\w*)?Element$/;\n\nconst testNode = (val: any) => {\n  const constructorName = val?.constructor?.name || \"\";\n  const { nodeType, tagName } = val;\n  const isCustomElement =\n    (typeof tagName === \"string\" && tagName.includes(\"-\")) ||\n    (typeof val.hasAttribute === \"function\" && val.hasAttribute(\"is\")) ||\n    val instanceof HTMLElement;\n\n  return (\n    (nodeType === ELEMENT_NODE &&\n      (ELEMENT_REGEXP.test(constructorName) || isCustomElement)) ||\n    (nodeType === TEXT_NODE && constructorName === \"Text\") ||\n    (nodeType === COMMENT_NODE && constructorName === \"Comment\") ||\n    // Don't check constructorName === \"DocumentFragment\" because it excludes ShadowRoot.\n    nodeType === FRAGMENT_NODE\n  );\n};\n\nexport const test: NewPlugin[\"test\"] = (val: any) =>\n  val?.constructor?.name && testNode(val);\n\ntype HandledType = Element | Text | Comment | DocumentFragment;\n\nfunction nodeIsText(node: HandledType): node is Text {\n  return node.nodeType === TEXT_NODE;\n}\n\nfunction nodeIsComment(node: HandledType): node is Comment {\n  return node.nodeType === COMMENT_NODE;\n}\n\nfunction nodeIsFragment(\n  node: HandledType,\n): node is DocumentFragment | ShadowRoot {\n  return node.nodeType === FRAGMENT_NODE;\n}\n\nexport function createDOMElementFilter(\n  filterNode: (node: Node) => boolean,\n): NewPlugin {\n  function getChildren(\n    node: Element | DocumentFragment | ShadowRoot,\n  ): (Node | Element | ShadowRoot)[] {\n    const children: (Node | Element | ShadowRoot)[] =\n      Array.prototype.slice.call(node.childNodes || node.children);\n\n    if (\n      \"shadowRoot\" in node &&\n      node.shadowRoot != null &&\n      node.shadowRoot.mode !== \"closed\"\n    ) {\n      children.unshift(node.shadowRoot);\n    }\n\n    return children.filter(filterNode);\n  }\n\n  return {\n    test: (val: any) => val?.constructor && testNode(val),\n    serialize: (\n      node: HandledType,\n      config: Config,\n      indentation: string,\n      depth: number,\n      refs: Refs,\n      printer: Printer,\n    ) => {\n      if (nodeIsText(node)) {\n        return printText(node.data, config);\n      }\n\n      if (nodeIsComment(node)) {\n        return printComment(node.data, config);\n      }\n\n      let type = \"DocumentFragment\";\n\n      if (\"tagName\" in node && node.tagName) {\n        type = node.tagName.toLowerCase();\n      } else if (node instanceof ShadowRoot) {\n        type = \"ShadowRoot\";\n      }\n\n      if (++depth > config.maxDepth) {\n        return printElementAsLeaf(type, config);\n      }\n\n      return printElement(\n        type,\n        printProps(\n          nodeIsFragment(node)\n            ? []\n            : Array.from(node.attributes)\n                .map((attr) => attr.name)\n                .sort(),\n          nodeIsFragment(node)\n            ? {}\n            : Array.from(node.attributes).reduce<Record<string, string>>(\n                (props, attribute) => {\n                  props[attribute.name] = attribute.value;\n                  return props;\n                },\n                {},\n              ),\n          config,\n          indentation + config.indent,\n          depth,\n          refs,\n          printer,\n        ),\n        printChildren(\n          getChildren(node) as unknown[],\n          config,\n          indentation + config.indent,\n          depth,\n          refs,\n          printer,\n        ),\n        config,\n        indentation,\n      );\n    },\n  };\n}\n","import { screen } from \"@testing-library/dom\";\nimport { logShadowDOM } from \"./log-shadow-dom\";\n\nexport function debug(...args: Parameters<typeof screen.debug>) {\n  let [element, maxLength, options] = args;\n\n  Array.isArray(element)\n    ? element.forEach((el) => logShadowDOM(el, maxLength, options))\n    : logShadowDOM(element, maxLength, options);\n}\n","import { debug } from \"./debug\";\nimport { screen } from \"@testing-library/dom\";\n\nimport * as shadowQueries from \"./shadow-queries\";\nimport {\n  AsyncScreenShadowMatcherParams,\n  AsyncScreenShadowRoleMatcherParams,\n  AsyncScreenShadowSelectorMatcherParams,\n  ScreenShadowMatcherParams,\n  ScreenShadowRoleMatcherParams,\n  ScreenShadowSelectorMatcherParams,\n} from \"./types\";\n\n// Shadows the following: https://testing-library.com/docs/queries/about/#priority\nconst shadowScreen = {\n  ...screen,\n  debug,\n  // Role\n  queryAllByShadowRole: <T extends HTMLElement>(\n    ...args: ScreenShadowRoleMatcherParams\n  ) =>\n    shadowQueries.queryAllByShadowRole<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  queryByShadowRole: <T extends HTMLElement>(\n    ...args: ScreenShadowRoleMatcherParams\n  ) =>\n    shadowQueries.queryByShadowRole<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getAllByShadowRole: <T extends HTMLElement>(\n    ...args: ScreenShadowRoleMatcherParams\n  ) =>\n    shadowQueries.getAllByShadowRole<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getByShadowRole: <T extends HTMLElement>(\n    ...args: ScreenShadowRoleMatcherParams\n  ) =>\n    shadowQueries.getByShadowRole<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  findAllByShadowRole: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowRoleMatcherParams\n  ) =>\n    shadowQueries.findAllByShadowRole<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n  findByShadowRole: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowRoleMatcherParams\n  ) =>\n    shadowQueries.findByShadowRole<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n\n  // Label Text\n  queryAllByShadowLabelText: <T extends HTMLElement>(\n    ...args: ScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.queryAllByShadowLabelText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  queryByShadowLabelText: <T extends HTMLElement>(\n    ...args: ScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.queryByShadowLabelText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getAllByShadowLabelText: <T extends HTMLElement>(\n    ...args: ScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.getAllByShadowLabelText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getByShadowLabelText: <T extends HTMLElement>(\n    ...args: ScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.getByShadowLabelText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  findAllByShadowLabelText: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.findAllByShadowLabelText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n  findByShadowLabelText: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.findByShadowLabelText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n\n  // Placeholder Text\n  queryAllByShadowPlaceholderText: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.queryAllByShadowPlaceholderText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  queryByShadowPlaceholderText: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.queryByShadowPlaceholderText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getAllByShadowPlaceholderText: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.getAllByShadowPlaceholderText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getByShadowPlaceholderText: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.getByShadowPlaceholderText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  findAllByShadowPlaceholderText: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowMatcherParams\n  ) =>\n    shadowQueries.findAllByShadowPlaceholderText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n  findByShadowPlaceholderText: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowMatcherParams\n  ) =>\n    shadowQueries.findByShadowPlaceholderText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n\n  // Text\n  queryAllByShadowText: <T extends HTMLElement>(\n    ...args: ScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.queryAllByShadowText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  queryByShadowText: <T extends HTMLElement>(\n    ...args: ScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.queryByShadowText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getAllByShadowText: <T extends HTMLElement>(\n    ...args: ScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.getAllByShadowText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getByShadowText: <T extends HTMLElement>(\n    ...args: ScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.getByShadowText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  findAllByShadowText: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.findAllByShadowText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n  findByShadowText: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowSelectorMatcherParams\n  ) =>\n    shadowQueries.findByShadowText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n\n  // Display Value\n  queryAllByShadowDisplayValue: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.queryAllByShadowDisplayValue<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  queryByShadowDisplayValue: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.queryByShadowDisplayValue<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getAllByShadowDisplayValue: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.getAllByShadowDisplayValue<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getByShadowDisplayValue: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.getByShadowDisplayValue<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  findAllByShadowDisplayValue: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowMatcherParams\n  ) =>\n    shadowQueries.findAllByShadowDisplayValue<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n  findByShadowDisplayValue: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowMatcherParams\n  ) =>\n    shadowQueries.findByShadowDisplayValue<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n\n  // Alt Text\n  queryAllByShadowAltText: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.queryAllByShadowAltText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  queryByShadowAltText: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.queryByShadowAltText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getAllByShadowAltText: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.getAllByShadowAltText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getByShadowAltText: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.getByShadowAltText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  findAllByShadowAltText: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowMatcherParams\n  ) =>\n    shadowQueries.findAllByShadowAltText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n  findByShadowAltText: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowMatcherParams\n  ) =>\n    shadowQueries.findByShadowAltText<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n\n  // Title\n  queryAllByShadowTitle: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.queryAllByShadowTitle<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  queryByShadowTitle: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.queryByShadowTitle<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getAllByShadowTitle: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.getAllByShadowTitle<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getByShadowTitle: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.getByShadowTitle<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  findAllByShadowTitle: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowMatcherParams\n  ) =>\n    shadowQueries.findAllByShadowTitle<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n  findByShadowTitle: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowMatcherParams\n  ) =>\n    shadowQueries.findByShadowTitle<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n\n  // Test Id\n  queryAllByShadowTestId: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.queryAllByShadowTestId<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  queryByShadowTestId: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.queryByShadowTestId<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getAllByShadowTestId: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.getAllByShadowTestId<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  getByShadowTestId: <T extends HTMLElement>(\n    ...args: ScreenShadowMatcherParams\n  ) =>\n    shadowQueries.getByShadowTestId<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n    ),\n  findAllByShadowTestId: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowMatcherParams\n  ) =>\n    shadowQueries.findAllByShadowTestId<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n  findByShadowTestId: <T extends HTMLElement>(\n    ...args: AsyncScreenShadowMatcherParams\n  ) =>\n    shadowQueries.findByShadowTestId<T>(\n      document.documentElement,\n      args[0],\n      args[1],\n      args[2],\n    ),\n};\n\nexport { shadowScreen };\n","import { queries, within } from \"@testing-library/dom\";\n\nimport * as shadowQueries from \"./shadow-queries\";\n\nconst allQueries = {\n  ...queries,\n  ...shadowQueries,\n};\n\nexport function shadowWithin(element: HTMLElement) {\n  const withinObj = within(element, allQueries);\n\n  // This is a gross and ugly hack. However, the `allQueries` function from RTL doesn't\n  // preserve generics, so we generate the within object, and then overwrite the \"shadow\" functions to properly\n  // support generics.\n  const shadowWithinObj = {\n    // Role\n    queryAllByShadowRole: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryAllByShadowRole>\n    ) =>\n      withinObj.queryAllByShadowRole(...args) as ReturnType<\n        typeof shadowQueries.queryAllByShadowRole<T>\n      >,\n    queryByShadowRole: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryByShadowRole>\n    ) =>\n      withinObj.queryByShadowRole(...args) as ReturnType<\n        typeof shadowQueries.queryByShadowRole<T>\n      >,\n    getAllByShadowRole: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getAllByShadowRole>\n    ) =>\n      withinObj.getAllByShadowRole(...args) as ReturnType<\n        typeof shadowQueries.getAllByShadowRole<T>\n      >,\n    getByShadowRole: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getByShadowRole>\n    ) =>\n      withinObj.getByShadowRole(...args) as ReturnType<\n        typeof shadowQueries.getByShadowRole<T>\n      >,\n    findAllByShadowRole: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findAllByShadowRole>\n    ) =>\n      withinObj.findAllByShadowRole(...args) as ReturnType<\n        typeof shadowQueries.findAllByShadowRole<T>\n      >,\n    findByShadowRole: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findByShadowRole>\n    ) =>\n      withinObj.findByShadowRole(...args) as ReturnType<\n        typeof shadowQueries.findByShadowRole<T>\n      >,\n\n    // Label Text\n    queryAllByShadowLabelText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryAllByShadowLabelText>\n    ) =>\n      withinObj.queryAllByShadowLabelText(...args) as ReturnType<\n        typeof shadowQueries.queryAllByShadowLabelText<T>\n      >,\n    queryByShadowLabelText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryByShadowLabelText>\n    ) =>\n      withinObj.queryByShadowLabelText(...args) as ReturnType<\n        typeof shadowQueries.queryByShadowLabelText<T>\n      >,\n    getAllByShadowLabelText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getAllByShadowLabelText>\n    ) =>\n      withinObj.getAllByShadowLabelText(...args) as ReturnType<\n        typeof shadowQueries.getAllByShadowLabelText<T>\n      >,\n    getByShadowLabelText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getByShadowLabelText>\n    ) =>\n      withinObj.getByShadowLabelText(...args) as ReturnType<\n        typeof shadowQueries.getByShadowLabelText<T>\n      >,\n    findAllByShadowLabelText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findAllByShadowLabelText>\n    ) =>\n      withinObj.findAllByShadowLabelText(...args) as ReturnType<\n        typeof shadowQueries.findAllByShadowLabelText<T>\n      >,\n    findByShadowLabelText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findByShadowLabelText>\n    ) =>\n      withinObj.findByShadowLabelText(...args) as ReturnType<\n        typeof shadowQueries.findByShadowLabelText<T>\n      >,\n\n    // Placeholder Text\n    queryAllByShadowPlaceholderText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryAllByShadowPlaceholderText>\n    ) =>\n      withinObj.queryAllByShadowPlaceholderText(...args) as ReturnType<\n        typeof shadowQueries.queryAllByShadowPlaceholderText<T>\n      >,\n    queryByShadowPlaceholderText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryByShadowPlaceholderText>\n    ) =>\n      withinObj.queryByShadowPlaceholderText(...args) as ReturnType<\n        typeof shadowQueries.queryByShadowPlaceholderText<T>\n      >,\n    getAllByShadowPlaceholderText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getAllByShadowPlaceholderText>\n    ) =>\n      withinObj.getAllByShadowPlaceholderText(...args) as ReturnType<\n        typeof shadowQueries.getAllByShadowPlaceholderText<T>\n      >,\n    getByShadowPlaceholderText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getByShadowPlaceholderText>\n    ) =>\n      withinObj.getByShadowPlaceholderText(...args) as ReturnType<\n        typeof shadowQueries.getByShadowPlaceholderText<T>\n      >,\n    findAllByShadowPlaceholderText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findAllByShadowPlaceholderText>\n    ) =>\n      withinObj.findAllByShadowPlaceholderText(...args) as ReturnType<\n        typeof shadowQueries.findAllByShadowPlaceholderText<T>\n      >,\n    findByShadowPlaceholderText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findByShadowPlaceholderText>\n    ) =>\n      withinObj.findByShadowPlaceholderText(...args) as ReturnType<\n        typeof shadowQueries.findByShadowPlaceholderText<T>\n      >,\n\n    // Text\n    queryAllByShadowText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryAllByShadowText>\n    ) =>\n      withinObj.queryAllByShadowText(...args) as ReturnType<\n        typeof shadowQueries.queryAllByShadowText<T>\n      >,\n    queryByShadowText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryByShadowText>\n    ) =>\n      withinObj.queryByShadowText(...args) as ReturnType<\n        typeof shadowQueries.queryByShadowText<T>\n      >,\n    getAllByShadowText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getAllByShadowText>\n    ) =>\n      withinObj.getAllByShadowText(...args) as ReturnType<\n        typeof shadowQueries.getAllByShadowText<T>\n      >,\n    getByShadowText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getByShadowText>\n    ) =>\n      withinObj.getByShadowText(...args) as ReturnType<\n        typeof shadowQueries.getByShadowText<T>\n      >,\n    findAllByShadowText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findAllByShadowText>\n    ) =>\n      withinObj.findAllByShadowText(...args) as ReturnType<\n        typeof shadowQueries.findAllByShadowText<T>\n      >,\n    findByShadowText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findByShadowText>\n    ) =>\n      withinObj.findByShadowText(...args) as ReturnType<\n        typeof shadowQueries.findByShadowText<T>\n      >,\n\n    // Display Value\n    queryAllByShadowDisplayValue: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryAllByShadowDisplayValue>\n    ) =>\n      withinObj.queryAllByShadowDisplayValue(...args) as ReturnType<\n        typeof shadowQueries.queryAllByShadowDisplayValue<T>\n      >,\n    queryByShadowDisplayValue: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryByShadowDisplayValue>\n    ) =>\n      withinObj.queryByShadowDisplayValue(...args) as ReturnType<\n        typeof shadowQueries.queryByShadowDisplayValue<T>\n      >,\n    getAllByShadowDisplayValue: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getAllByShadowDisplayValue>\n    ) =>\n      withinObj.getAllByShadowDisplayValue(...args) as ReturnType<\n        typeof shadowQueries.getAllByShadowDisplayValue<T>\n      >,\n    getByShadowDisplayValue: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getByShadowDisplayValue>\n    ) =>\n      withinObj.getByShadowDisplayValue(...args) as ReturnType<\n        typeof shadowQueries.getByShadowDisplayValue<T>\n      >,\n    findAllByShadowDisplayValue: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findAllByShadowDisplayValue>\n    ) =>\n      withinObj.findAllByShadowDisplayValue(...args) as ReturnType<\n        typeof shadowQueries.findAllByShadowDisplayValue<T>\n      >,\n    findByShadowDisplayValue: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findByShadowDisplayValue>\n    ) =>\n      withinObj.findByShadowDisplayValue(...args) as ReturnType<\n        typeof shadowQueries.findByShadowDisplayValue<T>\n      >,\n\n    // Alt Text\n    queryAllByShadowAltText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryAllByShadowAltText>\n    ) =>\n      withinObj.queryAllByShadowAltText(...args) as ReturnType<\n        typeof shadowQueries.queryAllByShadowAltText<T>\n      >,\n    queryByShadowAltText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryByShadowAltText>\n    ) =>\n      withinObj.queryByShadowAltText(...args) as ReturnType<\n        typeof shadowQueries.queryByShadowAltText<T>\n      >,\n    getAllByShadowAltText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getAllByShadowAltText>\n    ) =>\n      withinObj.getAllByShadowAltText(...args) as ReturnType<\n        typeof shadowQueries.getAllByShadowAltText<T>\n      >,\n    getByShadowAltText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getByShadowAltText>\n    ) =>\n      withinObj.getByShadowAltText(...args) as ReturnType<\n        typeof shadowQueries.getByShadowAltText<T>\n      >,\n    findAllByShadowAltText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findAllByShadowAltText>\n    ) =>\n      withinObj.findAllByShadowAltText(...args) as ReturnType<\n        typeof shadowQueries.findAllByShadowAltText<T>\n      >,\n    findByShadowAltText: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findByShadowAltText>\n    ) =>\n      withinObj.findByShadowAltText(...args) as ReturnType<\n        typeof shadowQueries.findByShadowAltText<T>\n      >,\n\n    // Title\n    queryAllByShadowTitle: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryAllByShadowTitle>\n    ) =>\n      withinObj.queryAllByShadowTitle(...args) as ReturnType<\n        typeof shadowQueries.queryAllByShadowTitle<T>\n      >,\n    queryByShadowTitle: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryByShadowTitle>\n    ) =>\n      withinObj.queryByShadowTitle(...args) as ReturnType<\n        typeof shadowQueries.queryByShadowTitle<T>\n      >,\n    getAllByShadowTitle: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getAllByShadowTitle>\n    ) =>\n      withinObj.getAllByShadowTitle(...args) as ReturnType<\n        typeof shadowQueries.getAllByShadowTitle<T>\n      >,\n    getByShadowTitle: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getByShadowTitle>\n    ) =>\n      withinObj.getByShadowTitle(...args) as ReturnType<\n        typeof shadowQueries.getByShadowTitle<T>\n      >,\n    findAllByShadowTitle: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findAllByShadowTitle>\n    ) =>\n      withinObj.findAllByShadowTitle(...args) as ReturnType<\n        typeof shadowQueries.findAllByShadowTitle<T>\n      >,\n    findByShadowTitle: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findByShadowTitle>\n    ) =>\n      withinObj.findByShadowTitle(...args) as ReturnType<\n        typeof shadowQueries.findByShadowTitle<T>\n      >,\n\n    // Test Id\n    queryAllByShadowTestId: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryAllByShadowTestId>\n    ) =>\n      withinObj.queryAllByShadowTestId(...args) as ReturnType<\n        typeof shadowQueries.queryAllByShadowTestId<T>\n      >,\n    queryByShadowTestId: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.queryByShadowTestId>\n    ) =>\n      withinObj.queryByShadowTestId(...args) as ReturnType<\n        typeof shadowQueries.queryByShadowTestId<T>\n      >,\n    getAllByShadowTestId: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getAllByShadowTestId>\n    ) =>\n      withinObj.getAllByShadowTestId(...args) as ReturnType<\n        typeof shadowQueries.getAllByShadowTestId<T>\n      >,\n    getByShadowTestId: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.getByShadowTestId>\n    ) =>\n      withinObj.getByShadowTestId(...args) as ReturnType<\n        typeof shadowQueries.getByShadowTestId<T>\n      >,\n    findAllByShadowTestId: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findAllByShadowTestId>\n    ) =>\n      withinObj.findAllByShadowTestId(...args) as ReturnType<\n        typeof shadowQueries.findAllByShadowTestId<T>\n      >,\n    findByShadowTestId: <T extends HTMLElement>(\n      ...args: Parameters<typeof withinObj.findByShadowTestId>\n    ) =>\n      withinObj.findByShadowTestId(...args) as ReturnType<\n        typeof shadowQueries.findByShadowTestId<T>\n      >,\n  };\n\n  // return withinFn\n\n  const finalObj = {\n    ...withinObj,\n    ...shadowWithinObj,\n  };\n\n  return finalObj;\n}\n"],"mappings":"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","names":["configure","getConfig","shadow_queries_exports","__export","findAllByShadowAltText","findAllByShadowDisplayValue","findAllByShadowLabelText","findAllByShadowPlaceholderText","findAllByShadowRole","findAllByShadowTestId","findAllByShadowText","findAllByShadowTitle","findByShadowAltText","findByShadowDisplayValue","findByShadowLabelText","findByShadowPlaceholderText","findByShadowRole","findByShadowTestId","findByShadowText","findByShadowTitle","getAllByShadowAltText","getAllByShadowDisplayValue","getAllByShadowLabelText","getAllByShadowPlaceholderText","getAllByShadowRole","getAllByShadowTestId","getAllByShadowText","getAllByShadowTitle","getByShadowAltText","getByShadowDisplayValue","getByShadowLabelText","getByShadowPlaceholderText","getByShadowRole","getByShadowTestId","getByShadowText","getByShadowTitle","queryAllByShadowAltText","queryAllByShadowDisplayValue","queryAllByShadowLabelText","queryAllByShadowPlaceholderText","queryAllByShadowRole","queryAllByShadowTestId","queryAllByShadowText","queryAllByShadowTitle","queryByShadowAltText","queryByShadowDisplayValue","queryByShadowLabelText","queryByShadowPlaceholderText","queryByShadowRole","queryByShadowTestId","queryByShadowText","queryByShadowTitle","buildQueries","queryAllByRole","queryAllByLabelText","queryAllByPlaceholderText","queryAllByText","queryAllByDisplayValue","queryAllByAltText","queryAllByTitle","queryAllByTestId","patchShadowRoot","patchDOM","patchSlotElement","removeDOMPatch","patchWrap","callback","val","string","str","qsa","els","_el","el","scratch","deepQuerySelector","container","selector","options","els","deepQuerySelectorAll","patchWrap","queriedElements","getAllElementsAndShadowRoots","el","recurse","elementsToProcess","elements","containerElement","toShadowQueries","queries","query","args","arg1","arg2","options","rest","queryAllByShadowRole","container","role","patchWrap","getAllElementsAndShadowRoots","el","queryAllByRole","getMultipleRoleError","_c","getMissingRoleError","_queryByShadowRole","_getAllByShadowRole","_getByShadowRole","_findAllByShadowRole","_findByShadowRole","buildQueries","queryByShadowRole","getAllByShadowRole","getByShadowRole","findAllByShadowRole","findByShadowRole","queryAllByShadowLabelText","id","queryAllByLabelText","getMultipleLabelTextError","getMissingLabelTextError","_queryByShadowLabelText","_getAllByShadowLabelText","_getByShadowLabelText","_findAllByShadowLabelText","_findByShadowLabelText","queryByShadowLabelText","getAllByShadowLabelText","getByShadowLabelText","findAllByShadowLabelText","findByShadowLabelText","queryAllByShadowPlaceholderText","queryAllByPlaceholderText","getMultiplePlaceholderTextError","getMissingPlaceholderTextError","_queryByShadowPlaceholderText","_getAllByShadowPlaceholderText","_getByShadowPlaceholderText","_findAllByShadowPlaceholderText","_findByShadowPlaceholderText","queryByShadowPlaceholderText","getAllByShadowPlaceholderText","getByShadowPlaceholderText","findAllByShadowPlaceholderText","findByShadowPlaceholderText","queryAllByShadowText","queryAllByText","getMultipleTextError","getMissingTextError","_queryByShadowText","_getAllByShadowText","_getByShadowText","_findAllByShadowText","_findByShadowText","queryByShadowText","getAllByShadowText","getByShadowText","findAllByShadowText","findByShadowText","queryAllByShadowDisplayValue","queryAllByDisplayValue","getMultipleDisplayValueError","getMissingDisplayValueError","_queryByShadowDisplayValue","_getAllByShadowDisplayValue","_getByShadowDisplayValue","_findAllByShadowDisplayValue","_findByShadowDisplayValue","queryByShadowDisplayValue","getAllByShadowDisplayValue","getByShadowDisplayValue","findAllByShadowDisplayValue","findByShadowDisplayValue","queryAllByShadowAltText","queryAllByAltText","getMultipleAltTextError","getMissingAltTextError","_queryByShadowAltText","_getAllByShadowAltText","_getByShadowAltText","_findAllByShadowAltText","_findByShadowAltText","queryByShadowAltText","getAllByShadowAltText","getByShadowAltText","findAllByShadowAltText","findByShadowAltText","queryAllByShadowTitle","queryAllByTitle","getMultipleTitleError","getMissingTitleError","_queryByShadowTitle","_getAllByShadowTitle","_getByShadowTitle","_findAllByShadowTitle","_findByShadowTitle","queryByShadowTitle","getAllByShadowTitle","getByShadowTitle","findAllByShadowTitle","findByShadowTitle","queryAllByShadowTestId","queryAllByTestId","getMultipleTestIdError","getMissingTestIdError","_queryByShadowTestId","_getAllByShadowTestId","_getByShadowTestId","_findAllByShadowTestId","_findByShadowTestId","queryByShadowTestId","getAllByShadowTestId","getByShadowTestId","findAllByShadowTestId","findByShadowTestId","logDOM","prettyDOM","getConfig","findWhiteSpace","removeDuplicateNewLines","str","prettyShadowDOM","args","dom","maxLength","options","plugin","createDOMElementFilter","filterCommentsAndDefaultIgnoreTagsTags","patchWrap","prettyDOM","escapeHTML","value","COMMENT_NODE","ELEMENT_NODE","getConfig","printProps","keys","props","config","indentation","depth","refs","printer","indentationNext","colors","key","printed","NodeTypeTextNode","printChildren","children","child","printedChild","printText","text","contentColor","printComment","comment","commentColor","printElement","type","printedProps","printedChildren","tagColor","printElementAsLeaf","TEXT_NODE","FRAGMENT_NODE","ELEMENT_REGEXP","testNode","val","_a","constructorName","nodeType","tagName","isCustomElement","nodeIsText","node","TEXT_NODE","nodeIsComment","COMMENT_NODE","nodeIsFragment","FRAGMENT_NODE","createDOMElementFilter","filterNode","getChildren","children","val","testNode","config","indentation","depth","refs","printer","printText","printComment","type","printElementAsLeaf","printElement","printProps","attr","props","attribute","printChildren","logShadowDOM","args","dom","maxLength","options","plugin","createDOMElementFilter","filterCommentsAndDefaultIgnoreTagsTags","patchWrap","logDOM","debug","args","element","maxLength","options","el","logShadowDOM","screen","shadowScreen","screen","debug","args","queryAllByShadowRole","queryByShadowRole","getAllByShadowRole","getByShadowRole","findAllByShadowRole","findByShadowRole","queryAllByShadowLabelText","queryByShadowLabelText","getAllByShadowLabelText","getByShadowLabelText","findAllByShadowLabelText","findByShadowLabelText","queryAllByShadowPlaceholderText","queryByShadowPlaceholderText","getAllByShadowPlaceholderText","getByShadowPlaceholderText","findAllByShadowPlaceholderText","findByShadowPlaceholderText","queryAllByShadowText","queryByShadowText","getAllByShadowText","getByShadowText","findAllByShadowText","findByShadowText","queryAllByShadowDisplayValue","queryByShadowDisplayValue","getAllByShadowDisplayValue","getByShadowDisplayValue","findAllByShadowDisplayValue","findByShadowDisplayValue","queryAllByShadowAltText","queryByShadowAltText","getAllByShadowAltText","getByShadowAltText","findAllByShadowAltText","findByShadowAltText","queryAllByShadowTitle","queryByShadowTitle","getAllByShadowTitle","getByShadowTitle","findAllByShadowTitle","findByShadowTitle","queryAllByShadowTestId","queryByShadowTestId","getAllByShadowTestId","getByShadowTestId","findAllByShadowTestId","findByShadowTestId","queries","within","allQueries","queries","shadow_queries_exports","shadowWithin","element","withinObj","within","args","configure","message","container","prettifiedDOM","prettyShadowDOM","error","getConfig"]}