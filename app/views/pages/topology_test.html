<!DOCTYPE html>
<meta charset="utf-8">

<svg width="960" height="600"></svg>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
var stateNodes = []
var stateLinks = []
var nodes = []
var links = []
var zoomScale = 1
var nodeColor = '#00b3ff'
var linkColor = '#bbb'

var options = {
  nominalBaseNodeSize: 18,
  nominalTextSize: 12,
  maxTextSize: 12,
  nominalStroke: 1.5,
  maxStroke: 4.5,
  maxBaseNodeSize: 36,
  minZoom: 0.1,
  maxZoom: 7
}

var width = window.innerWidth
var height = window.innerHeight
var svg = d3.select('svg')

//add encompassing group for the zoom
var graph = svg.append("g")
    .attr("class", "everything");

svg.attr('width', width).attr('height', height)
var linkElements,
    nodeElements,
    textElements

// we use svg groups to logically group the elements together
var linkGroup = graph.append('g').attr('class', 'links')
var nodeGroup = graph.append('g').attr('class', 'nodes')
var textGroup = graph.append('g').attr('class', 'texts')
// we use this reference to select/deselect
// after clicking the same element twice
var selectedId
// simulation setup with all forces
var linkForce = d3
                  .forceLink()
                  .id(function (link) { return link.id })
                  //.strength(function (link) { return link.strength })
                  // .distance(80)
                  .distance((link) => {
                    const targetOutgoingLinks = links.filter(l => l.source.id == link.target.id)
                    let length = targetOutgoingLinks.length/links.length * 500 + 80
                    return length
                  })

                  .iterations(5)
var simulation = d3
                  .forceSimulation()
                  .force('link', linkForce)
                  //.force('charge', d3.forceManyBody())
                  //.force('charge', d3.forceManyBody().strength(-20) )
                  //.force('charge', (value1, value2, distance, strength, alpha) => { console.log(value1, value2, distance, strength, alpha); })
                  //.force('charge', d3.forceManyBody().strength(-1000))
                  .force('center', d3.forceCenter(width / 2, height / 2))
                  //.force("x", d3.forceX(width/2))
                  //.force("y", d3.forceY(height/2))
                  //.force('many-body',d3.forceManyBody())
                  .force('charge', d3.forceManyBody().strength(-80))


//add zoom capabilities
var zoom_handler = d3.zoom()
  .on("zoom", zoom_actions);

//Zoom functions
function zoom_actions(){
  zoomScale = d3.event.transform.k
  //graph.attr("transform", d3.event.transform)
  var stroke = options.nominalStroke
  if (options.nominalStroke * zoomScale > options.maxStroke) {
    stroke = options.maxStroke / zoomScale
  }

  linkGroup.selectAll('line').style("stroke-width", stroke)
  nodeGroup.selectAll('circle').style("stroke-width", stroke)

  // var baseRadius = options.nominalBaseNodeSize
  // if (options.nominalBaseNodeSize * scale > options.maxBaseNodeSize) {
  //   baseRadius = options.maxBaseNodeSize / scale
  // }

  var textSize = zoomScale > 1 ? 5+zoomScale*zoomScale : 0
  if(textSize > options.maxTextSize) {
    textSize = options.maxTextSize
  }
  textGroup.selectAll('text').style("font-size", textSize + "px")

  graph.attr("transform", d3.event.transform)
}

zoom_handler(svg);


var dragDrop = d3.drag().on('start', function (node) {
  node.fx = node.x
  node.fy = node.y
})
.on('drag', function (node) {
  simulation.alphaTarget(0.7).restart()
  node.fx = d3.event.x
  node.fy = d3.event.y
})
.on('end', function (node) {
  if (!d3.event.active) {
    simulation.alphaTarget(0)
  }
  node.fx = null
  node.fy = null
})


function updateData(){
  // var index = nodes.findIndex(i => i.id == parentNode.id)
  // if(index == -1) {
  //   nodes.push({...parentNode})
  // }
  //
  // if (children && children.length>0) {
  //   for(let subNode of children) {
  //     var index = nodes.findIndex(i => i.id == subNode.id)
  //     nodes.push({...subNode, x: parentNode.x, y: parentNode.y})
  //     links.push({source: parentNode.id, target: subNode.id, strength: 1})
  //     if(subNode.children) {
  //       addChildren(subNode, subNode.children)
  //     }
  //   }
  // }
  for(let n of stateNodes) {
    let nodeLinks = stateLinks.filter(l => l.source==n.id || l.target==n.id)
    n.size = nodeLinks.length
  }

  nodes = stateNodes
  links = stateLinks

  updateSimulation()
}

function addChildren(parentNode, children) {
  var index = stateNodes.findIndex(n => n.id == parentNode.id)
  if(index==-1) stateNodes.push({...parentNode})

  if (children && children.length>0) {
    for(let subNode of children) {
      var index = stateNodes.findIndex(n => n.id == subNode.id)
      if(index==-1) stateNodes.push({...subNode, x: parentNode.x, y: parentNode.y})
      index = stateLinks.findIndex(l => l.source.id==parentNode.id && l.target.id==subNode.id)
      if(index==-1 && parentNode.id!=subNode.id) {
        stateLinks.push({source: parentNode.id, target: subNode.id, strength: 1})
      }
    }
  }
  updateData()
}

function removeChildren(childrenLinks) {
  for(let link of childrenLinks) {
    if(stateLinks.filter(l => l.source.id == link.target.id).length==0) {
      var index = nodes.findIndex(n => n.id == link.target.id)
      stateNodes.splice(index,1)
      index = stateLinks.findIndex(l => l.source.id==link.source.id && l.target.id==link.target.id )
      stateLinks.splice(index,1)
    }
  }
  updateData()
}

// select node is called on every click
// we either update the data according to the selection
// or reset the data if the same node is clicked twice
function selectNode(selectedNode) {
  var childrenLinks = links.filter(l => {
    return l.source.id == selectedNode.id &&
    links.filter(sl => sl.source.id==l.target.id).length==0 &&
    links.filter(sl => sl.target.id==l.target.id).length==1
  })

  if (childrenLinks.length>0) {
    removeChildren(childrenLinks)
  } else {
    loadRelatedObjects(selectedNode)
  }
  updateSimulation()
}

function loadRelatedObjects(currentNode) {
  fetch('http://localhost:3000/monsoon3/cache/related-objects?id='+currentNode.id, {
    method: "GET",
    credentials: "same-origin",
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      // "Content-Type": "application/x-www-form-urlencoded",
    }})
    .then(response => response.json())
    .then(data => {
      // console.log(data)
      addChildren(
        currentNode,
        data.map(d => {
          let label = d.cached_object_type
          if(d.name) label = label + `: ${d.name}`
          switch (d.cached_object_type) {
            case 'port':
              label = label + ` ${d.payload.fixed_ips.map(ip => ip.ip_address).join(', ')}`
              break
            case 'floatingip':
              label = label + `: ${d.payload.floating_ip_address}`
            default:
              break
          }
          return Object.assign(d, {
            level: 1,
            label
          })
        })
      )
    })
}

// addChildren(baseNodes[0],baseNodes.slice(1,baseNodes.length-1))

const initialId = 'a7471306-3a4d-4a0f-8edf-6b84d94c466e'
loadRelatedObjects({id: initialId, level: 1, label: 'Current Server', cached_object_type: 'server'})

function updateGraph() {
  // links
  linkElements = linkGroup.selectAll('line')
    .data(links, function (link) {
      return link.target.id + link.source.id
    })

  linkElements.exit().remove()

  var linkEnter = linkElements
    .enter().append('line')
    .attr('stroke-width', 1)
    .attr('stroke', linkColor)

  linkElements = linkEnter.merge(linkElements)

  // nodes
  nodeElements = nodeGroup.selectAll('.node')
    .data(nodes, function (node) { return node.id })

  nodeElements.exit().remove()

  var nodeEnter = nodeElements
    .enter().append("g")
    .attr('class', 'node')
    .style('cursor','pointer')
    .call(dragDrop)
    .on('mouseover', (d) => {
      // nodeGroup.selectAll()
      nodeGroup.selectAll('circle')
        .filter(n => n.id==d.id)
        .attr('fill', '#eee')
        .attr('stroke', nodeColor)
      linkGroup.selectAll('line')
        .filter(l => l.source.id == d.id || l.target.id==d.id)
        .style("stroke", nodeColor)
    })
    .on('mouseout', (d) => {
      nodeGroup.selectAll('circle')
        .filter(n => n.id==d.id)
        .attr('fill', 'white')
        .attr('stroke', linkColor)


      linkGroup.selectAll('line')
        .filter(l => l.source.id == d.id || l.target.id==d.id)
        .style("stroke", linkColor)
    })

  nodeEnter
    .append('circle')
    .attr('r', (d) => options.nominalBaseNodeSize)
    .attr('fill', 'white')
    .attr('stroke-width', 1)
    .attr('stroke', linkColor)

  var toggleChildren = nodeEnter.append('circle')
    .attr('r', 5)
    .attr("cx", -(options.nominalBaseNodeSize / 2+1)-7).attr("cy",options.nominalBaseNodeSize / 2 -7)
    .attr('fill','white')
    .attr('stroke-width', 1)
    .attr('stroke', linkColor)

 nodeEnter.append('text')
   .attr("dx", -(options.nominalBaseNodeSize / 2+1)-13).attr("dy",options.nominalBaseNodeSize / 2 -2)
  .attr('class','icon toggle')
  .style('fill', '#666')
  .style('font-family', 'FontAwesome')
  .style('font-size', options.nominalBaseNodeSize-4)
  .text('\uf055')
  .on('click', selectNode)

  var details = nodeEnter.append('text')
  .attr('class','icon details')
  .style('fill', '#666')
  .style('font-family', 'FontAwesome')
  .style('font-size', options.nominalBaseNodeSize-4)
  .attr("dx", -6).attr("dy",-12)
  .text('\uf05a')
  .on('click', () => console.log('Details'))

  var icons = nodeEnter.append('text')
    .attr('class','icon symbol')
    .style('fill', nodeColor)
    .style('font-family', 'FontAwesome')
    .style('font-size', options.nominalBaseNodeSize)
    .attr("dx", -options.nominalBaseNodeSize / 2+1).attr("dy",options.nominalBaseNodeSize / 2 -2)
    .text((d) => {
      switch (d.cached_object_type) {
        case 'network':
          return '\uf0c2'
        case 'server':
          return '\uf0a0'
        case 'router':
          return '\uf0e8'
        case 'port':
          return '\uf0ec'
        case 'security_group':
          return '\uf132'
        case 'volume':
          return '\uf1c0'
        case 'server':
          return '\uf233'
        case 'project':
          return '\uf288'
        case 'floatingip':
          return '\uf0ac'
        default:
          break
      }
    })


  nodeElements = nodeEnter.merge(nodeElements)

  // texts
  textElements = textGroup.selectAll('text')
    .data(nodes, function (node) { return node.id })
  textElements.exit().remove()

  var textSize = zoomScale > 1 ? 5+zoomScale*zoomScale : 0
  if(textSize > options.maxTextSize) {
    textSize = options.maxTextSize
  }
  var textEnter = textElements
    .enter()
    .append('text')
    .text(function (node) { return node.label })
    .attr('font-size', textSize)
    .attr('fill',nodeColor)
    .attr('dx', 19)
    .attr('dy', 3)
  textElements = textEnter.merge(textElements)
}

function updateSimulation() {
  updateGraph()
  simulation.nodes(nodes).on('tick', () => {
    // nodeGroup.selectAll('circle')
    //   .attr("transform", (d) => "scale("+(1+(d.size || 1)/links.length)+")")
    nodeElements
      .attr("transform", (d) => "translate(" + d.x + "," + d.y + ")")
    textElements
      .attr('x', function (node) { return node.x })
      .attr('y', function (node) { return node.y })
    linkElements
      .attr('x1', function (link) { return link.source.x })
      .attr('y1', function (link) { return link.source.y })
      .attr('x2', function (link) { return link.target.x })
      .attr('y2', function (link) { return link.target.y })
  })
  simulation.force('link').links(links)
  simulation.alphaTarget(0.02).restart()
}
// last but not least, we call updateSimulation
// to trigger the initial render
updateSimulation()
</script>
